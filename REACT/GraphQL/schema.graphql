schema {
  query: Query
}

type Article {
  id: Int!
  code: String!
  name: String!
  description: String
  unit: String!
}

type Contractor {
  id: Int!
  code: String!
  name: String!
  description: String
}

type Document {
  id: Int!
  number: String!
  executeDate: DateTime
  description: String
  contractor: Contractor!
  items: [DocumentItem!]!
}

type DocumentItem {
  id: Int!
  document: Document!
  quantity: Decimal!
  description: String
  article: Article!
}

type Query {
  documents(where: DocumentFilterInput @cost(weight: "10") order: [DocumentSortInput!] @cost(weight: "10")): [Document!]! @cost(weight: "10")
}

input ArticleFilterInput {
  and: [ArticleFilterInput!]
  or: [ArticleFilterInput!]
  id: IntOperationFilterInput
  code: StringOperationFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  unit: StringOperationFilterInput
}

input ContractorFilterInput {
  and: [ContractorFilterInput!]
  or: [ContractorFilterInput!]
  id: IntOperationFilterInput
  code: StringOperationFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
}

input ContractorSortInput {
  id: SortEnumType @cost(weight: "10")
  code: SortEnumType @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
}

input DateTimeOperationFilterInput {
  eq: DateTime @cost(weight: "10")
  neq: DateTime @cost(weight: "10")
  in: [DateTime] @cost(weight: "10")
  nin: [DateTime] @cost(weight: "10")
  gt: DateTime @cost(weight: "10")
  ngt: DateTime @cost(weight: "10")
  gte: DateTime @cost(weight: "10")
  ngte: DateTime @cost(weight: "10")
  lt: DateTime @cost(weight: "10")
  nlt: DateTime @cost(weight: "10")
  lte: DateTime @cost(weight: "10")
  nlte: DateTime @cost(weight: "10")
}

input DecimalOperationFilterInput {
  eq: Decimal @cost(weight: "10")
  neq: Decimal @cost(weight: "10")
  in: [Decimal] @cost(weight: "10")
  nin: [Decimal] @cost(weight: "10")
  gt: Decimal @cost(weight: "10")
  ngt: Decimal @cost(weight: "10")
  gte: Decimal @cost(weight: "10")
  ngte: Decimal @cost(weight: "10")
  lt: Decimal @cost(weight: "10")
  nlt: Decimal @cost(weight: "10")
  lte: Decimal @cost(weight: "10")
  nlte: Decimal @cost(weight: "10")
}

input DocumentFilterInput {
  and: [DocumentFilterInput!]
  or: [DocumentFilterInput!]
  id: IntOperationFilterInput
  number: StringOperationFilterInput
  executeDate: DateTimeOperationFilterInput
  description: StringOperationFilterInput
  contractor: ContractorFilterInput
  items: ListFilterInputTypeOfDocumentItemFilterInput
}

input DocumentItemFilterInput {
  and: [DocumentItemFilterInput!]
  or: [DocumentItemFilterInput!]
  id: IntOperationFilterInput
  document: DocumentFilterInput
  quantity: DecimalOperationFilterInput
  description: StringOperationFilterInput
  article: ArticleFilterInput
}

input DocumentSortInput {
  id: SortEnumType @cost(weight: "10")
  number: SortEnumType @cost(weight: "10")
  executeDate: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  contractor: ContractorSortInput @cost(weight: "10")
}

input IntOperationFilterInput {
  eq: Int @cost(weight: "10")
  neq: Int @cost(weight: "10")
  in: [Int] @cost(weight: "10")
  nin: [Int] @cost(weight: "10")
  gt: Int @cost(weight: "10")
  ngt: Int @cost(weight: "10")
  gte: Int @cost(weight: "10")
  ngte: Int @cost(weight: "10")
  lt: Int @cost(weight: "10")
  nlt: Int @cost(weight: "10")
  lte: Int @cost(weight: "10")
  nlte: Int @cost(weight: "10")
}

input ListFilterInputTypeOfDocumentItemFilterInput {
  all: DocumentItemFilterInput @cost(weight: "10")
  none: DocumentItemFilterInput @cost(weight: "10")
  some: DocumentItemFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String @cost(weight: "10")
  neq: String @cost(weight: "10")
  contains: String @cost(weight: "20")
  ncontains: String @cost(weight: "20")
  in: [String] @cost(weight: "10")
  nin: [String] @cost(weight: "10")
  startsWith: String @cost(weight: "20")
  nstartsWith: String @cost(weight: "20")
  endsWith: String @cost(weight: "20")
  nendsWith: String @cost(weight: "20")
}

enum SortEnumType {
  ASC
  DESC
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost("The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc." weight: String!) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `Decimal` scalar type represents a decimal floating-point number."
scalar Decimal